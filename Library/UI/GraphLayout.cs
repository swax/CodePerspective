using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics;
using System.Threading.Tasks;
using System.Collections.Concurrent;

namespace XLibrary
{
    /// <summary>
    /// Implements improved hierarchical graph layout algorithms with performance optimizations
    /// Generated by Claude 3.7, just wow
    /// </summary>
    public class GraphLayout
    {
        // Cache to store previous barycenter values to avoid recalculations
        private static Dictionary<NodeModel, float> _cachedBarycenterValues = new Dictionary<NodeModel, float>();
        
        // Track which nodes were modified since last layout
        private static HashSet<int> _dirtyNodes = new HashSet<int>();
        
        // Configuration settings
        public static class Config
        {
            public static int MaxSweepCount = 8;
            public static int MinSweepCount = 2;
            public static float ConvergenceThreshold = 0.01f;
            public static bool UseParallelProcessing = true;
            public static bool UseIncrementalLayout = true;
            public static bool EnableEarlyTermination = true;
            public static bool EnablePathStraightening = true;  // New setting for path straightening
            public static float PathStraighteningStrength = 0.8f;  // Control how aggressively to straighten paths
            public static float EdgeBundlingFactor = 0.3f;  // Control how much to bundle parallel edges
        }
        
        /// <summary>
        /// Mark specific nodes as needing layout updates
        /// </summary>
        public static void MarkNodesForUpdate(IEnumerable<int> nodeIds)
        {
            foreach (var id in nodeIds)
                _dirtyNodes.Add(id);
        }
        
        /// <summary>
        /// Clear cache when graph structure changes significantly
        /// </summary>
        public static void ClearCache()
        {
            _cachedBarycenterValues.Clear();
            _dirtyNodes.Clear();
        }

        /// <summary>
        /// Applies the Sugiyama layout algorithm to improve the graph's appearance
        /// with optimizations for real-time performance
        /// </summary>
        public static void ApplySugiyamaLayout(Graph graph, bool forceFullLayout = false)
        {
            // Determine if we can do incremental layout
            bool useIncremental = Config.UseIncrementalLayout && !forceFullLayout && _dirtyNodes.Count > 0;
            
            // Optimize algorithm intensity based on graph size
            int sweepCount = Math.Max(
                Config.MinSweepCount, 
                Math.Min(Config.MaxSweepCount, graph.NodeMap.Count / 50)
            );
            
            // Phase 1: Apply crossing minimization
            MinimizeCrossings(graph, sweepCount, useIncremental);
            
            // New Phase: Straighten paths for edges with intermediate nodes
            if (Config.EnablePathStraightening)
            {
                StraightenIntermediatePaths(graph, useIncremental);
            }
            
            // Phase 2: Assign optimal y-coordinates within ranks
            OptimizeNodePositions(graph, useIncremental);
            
            // Phase 3: Final smoothing of multi-rank edge paths
            if (Config.EnablePathStraightening)
            {
                SmoothEdgePaths(graph, useIncremental);
            }
            
            // Clear dirty nodes as they've been processed
            _dirtyNodes.Clear();
        }

        /// <summary>
        /// Minimizes edge crossings between ranks using the barycenter heuristic
        /// </summary>
        private static void MinimizeCrossings(Graph graph, int sweepCount, bool incremental)
        {
            float prevLayoutEnergy = float.MaxValue;
            
            for (int i = 0; i < sweepCount; i++)
            {
                if (i % 2 == 0)
                {
                    // Downward sweep (from top to bottom)
                    for (int r = 0; r < graph.Ranks.Length - 1; r++)
                    {
                        // Skip ranks that don't need updating in incremental mode
                        if (incremental && !RankContainsDirtyNodes(graph.Ranks[r], graph))
                            continue;
                            
                        OrderRankByBarycenter(graph, r, true);
                    }
                }
                else
                {
                    // Upward sweep (from bottom to top)
                    for (int r = graph.Ranks.Length - 1; r > 0; r--)
                    {
                        // Skip ranks that don't need updating in incremental mode
                        if (incremental && !RankContainsDirtyNodes(graph.Ranks[r], graph))
                            continue;
                            
                        OrderRankByBarycenter(graph, r, false);
                    }
                }
                
                // Early termination if layout has converged
                if (Config.EnableEarlyTermination && i > 0 && i >= Config.MinSweepCount)
                {
                    float layoutEnergy = CalculateLayoutEnergy(graph);
                    float change = Math.Abs(prevLayoutEnergy - layoutEnergy);
                    if (change < Config.ConvergenceThreshold * graph.NodeMap.Count)
                        break;
                    prevLayoutEnergy = layoutEnergy;
                }
            }
        }

        /// <summary>
        /// Calculates a metric for layout stability to detect convergence
        /// </summary>
        private static float CalculateLayoutEnergy(Graph graph)
        {
            float energy = 0;
            foreach (var rank in graph.Ranks)
            {
                foreach (var node in rank.Column)
                {
                    float nodeEnergy = CalculateNodeEnergy(node, graph);
                    energy += nodeEnergy;
                }
            }
            return energy;
        }

        /// <summary>
        /// Calculates energy for a single node based on edge distances
        /// </summary>
        private static float CalculateNodeEnergy(NodeModel node, Graph graph)
        {
            float energy = 0;
            
            if (node.EdgesOut != null)
            {
                foreach (var destId in node.EdgesOut)
                {
                    if (graph.NodeMap.TryGetValue(destId, out NodeModel dest))
                    {
                        float dy = node.ScaledLocation.Y - dest.ScaledLocation.Y;
                        energy += dy * dy;
                    }
                }
            }
            
            if (node.EdgesIn != null)
            {
                foreach (var srcId in node.EdgesIn)
                {
                    if (graph.NodeMap.TryGetValue(srcId, out NodeModel src))
                    {
                        float dy = node.ScaledLocation.Y - src.ScaledLocation.Y;
                        energy += dy * dy;
                    }
                }
            }
            
            return energy;
        }

        /// <summary>
        /// Checks if a rank contains any nodes marked as dirty
        /// </summary>
        private static bool RankContainsDirtyNodes(Rank rank, Graph graph)
        {
            return rank.Column.Any(node => _dirtyNodes.Contains(node.ID) || 
                   (node.EdgesIn != null && node.EdgesIn.Any(id => _dirtyNodes.Contains(id))) ||
                   (node.EdgesOut != null && node.EdgesOut.Any(id => _dirtyNodes.Contains(id))));
        }

        /// <summary>
        /// Orders nodes in a rank using the barycenter heuristic
        /// </summary>
        private static void OrderRankByBarycenter(Graph graph, int rankIndex, bool downwardDirection)
        {
            Rank rank = graph.Ranks[rankIndex];
            
            // No need to sort if there's only one node or no nodes
            if (rank.Column.Count <= 1) return;
            
            // Calculate barycenter values for each node
            Dictionary<NodeModel, float> barycenterValues = new Dictionary<NodeModel, float>();

            // Use parallel processing for larger graphs
            if (Config.UseParallelProcessing && rank.Column.Count > 10)
            {
                var concurrentDict = new ConcurrentDictionary<NodeModel, float>();
                
                Parallel.ForEach(rank.Column, node => {
                    float barycenter = CalculateBarycenter(node, graph, downwardDirection);
                    concurrentDict.TryAdd(node, barycenter);
                });
                
                barycenterValues = new Dictionary<NodeModel, float>(concurrentDict);
            }
            else
            {
                foreach (var node in rank.Column)
                {
                    // Check cache first to avoid recalculation
                    string cacheKey = $"{node.ID}_{downwardDirection}";
                    
                    float barycenter;
                    if (!_dirtyNodes.Contains(node.ID) && 
                        _cachedBarycenterValues.TryGetValue(node, out barycenter))
                    {
                        // Use cached value
                    }
                    else
                    {
                        barycenter = CalculateBarycenter(node, graph, downwardDirection);
                        _cachedBarycenterValues[node] = barycenter;
                    }
                    
                    barycenterValues[node] = barycenter;
                }
            }
            
            // Sort nodes by their barycenter values
            rank.Column = rank.Column.OrderBy(n => barycenterValues[n]).ToList();
            
            // Reposition nodes in the sorted order
            float x = rank.Column[0].ScaledLocation.X; // Preserve x coordinate
            RepositionRank(graph, rank, x);
        }

        /// <summary>
        /// Calculates the barycenter value for a node based on connected nodes
        /// </summary>
        private static float CalculateBarycenter(NodeModel node, Graph graph, bool useOutgoing)
        {
            List<float> connectedPositions = new List<float>();
            
            if (useOutgoing && node.EdgesOut != null)
            {
                foreach (var destId in node.EdgesOut)
                {
                    if (graph.NodeMap.TryGetValue(destId, out NodeModel dest))
                    {
                        // If using intermediates, use those positions
                        if (node.Intermediates != null && node.Intermediates.ContainsKey(destId))
                        {
                            connectedPositions.Add(node.Intermediates[destId][0].ScaledLocation.Y);
                        }
                        else
                        {
                            connectedPositions.Add(dest.ScaledLocation.Y);
                        }
                    }
                }
            }
            else if (!useOutgoing && node.EdgesIn != null)
            {
                foreach (var srcId in node.EdgesIn)
                {
                    if (graph.NodeMap.TryGetValue(srcId, out NodeModel src))
                    {
                        // If using intermediates, use those positions
                        if (src.Intermediates != null && src.Intermediates.ContainsKey(node.ID))
                        {
                            connectedPositions.Add(src.Intermediates[node.ID].Last().ScaledLocation.Y);
                        }
                        else
                        {
                            connectedPositions.Add(src.ScaledLocation.Y);
                        }
                    }
                }
            }
            
            // Handle adjacents for intermediate nodes
            if (node.Adjacents != null)
            {
                foreach (var adj in node.Adjacents)
                {
                    connectedPositions.Add(adj.ScaledLocation.Y);
                }
            }
            
            if (connectedPositions.Count == 0)
            {
                // If no connections, keep current position as barycenter
                return node.ScaledLocation.Y;
            }
            
            // Fast average calculation
            float sum = 0;
            for (int i = 0; i < connectedPositions.Count; i++)
                sum += connectedPositions[i];
                
            return sum / connectedPositions.Count;
        }

        /// <summary>
        /// Optimizes node positions to minimize edge length while maintaining rank order
        /// </summary>
        private static void OptimizeNodePositions(Graph graph, bool incremental)
        {
            // First, apply force-directed positioning within each rank
            foreach (var rank in graph.Ranks)
            {
                // Skip ranks that don't need updating in incremental mode
                if (incremental && !RankContainsDirtyNodes(rank, graph))
                    continue;
                    
                OptimizeRankPositions(graph, rank);
            }
            
            // Reduce iterations for better performance 
            int iterations = incremental ? 1 : 2;
            
            // Then, apply global optimization to improve edge routing
            for (int i = 0; i < iterations; i++)
            {
                ApplyVerticalSpacing(graph, incremental);
                
                // Add intermediate path optimization in the global phase
                if (Config.EnablePathStraightening)
                {
                    OptimizeIntermediateNodeAlignment(graph, incremental);
                }
            }
        }

        /// <summary>
        /// Optimizes positions of nodes within a single rank
        /// </summary>
        private static void OptimizeRankPositions(Graph graph, Rank rank)
        {
            float minHeightSpace = graph.ScaledHeight * 0.2f / Math.Max(1, rank.Column.Count * 2);
            
            // Step 1: Calculate ideal positions based on connected nodes
            Dictionary<NodeModel, float> idealPositions = new Dictionary<NodeModel, float>();
            
            // Use parallel processing for larger ranks
            if (Config.UseParallelProcessing && rank.Column.Count > 10)
            {
                var concurrentDict = new ConcurrentDictionary<NodeModel, float>();
                
                Parallel.ForEach(rank.Column, node => {
                    float idealY = CalculateIdealPosition(node);
                    concurrentDict.TryAdd(node, idealY);
                });
                
                idealPositions = new Dictionary<NodeModel, float>(concurrentDict);
            }
            else
            {
                foreach (var node in rank.Column)
                {
                    idealPositions[node] = CalculateIdealPosition(node);
                }
            }
            
            // Step 2: Apply constraints to maintain ordering and spacing
            float lowerBound = graph.ScaledOffset + minHeightSpace;
            
            for (int i = 0; i < rank.Column.Count; i++)
            {
                NodeModel node = rank.Column[i];
                float halfSize = node.ScaledSize / 2;
                
                // Calculate lower bound based on previous node
                if (i > 0)
                {
                    NodeModel prevNode = rank.Column[i - 1];
                    lowerBound = prevNode.ScaledLocation.Y + (prevNode.ScaledSize / 2) + minHeightSpace;
                }
                
                // Calculate upper bound based on graph boundaries
                float upperBound = graph.ScaledOffset + graph.ScaledHeight - minHeightSpace;
                
                // Constrain position
                float idealY = idealPositions[node];
                float constrainedY = Math.Max(lowerBound + halfSize, Math.Min(idealY, upperBound - halfSize));
                
                node.ScaledLocation.Y = constrainedY;
                
                // Update lower bound for next node
                lowerBound = constrainedY + halfSize;
            }
        }

        /// <summary>
        /// Calculates the ideal position for a node based on connected nodes
        /// </summary>
        private static float CalculateIdealPosition(NodeModel node)
        {
            float sum = 0;
            int count = 0;
            
            // Consider outgoing edges
            if (node.EdgesOut != null)
            {
                foreach (var destId in node.EdgesOut)
                {
                    if (node.Intermediates != null && node.Intermediates.ContainsKey(destId))
                    {
                        sum += node.Intermediates[destId][0].ScaledLocation.Y;
                        count++;
                    }
                    else if (node.PositionMap != null && node.PositionMap.ContainsKey(destId))
                    {
                        sum += node.PositionMap[destId].ScaledLocation.Y;
                        count++;
                    }
                }
            }
            
            // Consider incoming edges
            if (node.EdgesIn != null)
            {
                foreach (var srcId in node.EdgesIn)
                {
                    if (node.PositionMap != null && node.PositionMap.ContainsKey(srcId))
                    {
                        NodeModel sourceNode = node.PositionMap[srcId];
                        if (sourceNode.Intermediates != null && sourceNode.Intermediates.ContainsKey(node.ID))
                        {
                            sum += sourceNode.Intermediates[node.ID].Last().ScaledLocation.Y;
                        }
                        else
                        {
                            sum += sourceNode.ScaledLocation.Y;
                        }
                        count++;
                    }
                }
            }
            
            // Consider adjacent nodes (for intermediates)
            if (node.Adjacents != null)
            {
                foreach (var adj in node.Adjacents)
                {
                    sum += adj.ScaledLocation.Y;
                    count++;
                }
            }
            
            if (count == 0)
                return node.ScaledLocation.Y;
                
            return sum / count;
        }

        /// <summary>
        /// Applies vertical spacing to ensure nodes are distributed evenly
        /// </summary>
        private static void ApplyVerticalSpacing(Graph graph, bool incremental)
        {
            // Apply a global optimization step to improve vertical spacing
            foreach (var rank in graph.Ranks)
            {
                if (rank.Column.Count <= 1) continue;
                if (incremental && !RankContainsDirtyNodes(rank, graph)) continue;
                
                float availableSpace = graph.ScaledHeight;
                float nodeSpace = availableSpace / rank.Column.Count;
                float currentY = graph.ScaledOffset + (nodeSpace / 2);
                
                // Distribute nodes with even spacing
                foreach (var node in rank.Column)
                {
                    // Move node position 70% toward the evenly-spaced position
                    // and 30% toward its current position (connected-node-based)
                    float evenlySpacedY = currentY;
                    node.ScaledLocation.Y = (0.7f * evenlySpacedY) + (0.3f * node.ScaledLocation.Y);
                    currentY += nodeSpace;
                }
            }
        }

        /// <summary>
        /// Repositions nodes in a rank at equal vertical spacing
        /// </summary>
        private static void RepositionRank(Graph graph, Rank rank, float xPos)
        {
            float spacePerRow = graph.ScaledHeight / Math.Max(1, rank.Column.Count);
            float yOffset = spacePerRow / 2.0f;
            
            foreach (var node in rank.Column)
            {
                node.ScaledLocation.X = xPos;
                node.ScaledLocation.Y = graph.ScaledOffset + yOffset;
                yOffset += spacePerRow;
            }
        }

        /// <summary>
        /// Straightens paths through intermediate nodes to reduce jagged edge routing
        /// </summary>
        private static void StraightenIntermediatePaths(Graph graph, bool incremental)
        {
            // For each node that has outgoing edges with intermediates
            foreach (var node in graph.NodeMap.Values)
            {
                // Skip if no outgoing edges or no intermediates
                if (node.EdgesOut == null || node.Intermediates == null || node.Intermediates.Count == 0)
                    continue;
                
                // Skip nodes that don't need updating in incremental mode
                if (incremental && !_dirtyNodes.Contains(node.ID) && 
                    !node.EdgesOut.Any(id => _dirtyNodes.Contains(id)))
                    continue;
                
                // Process each edge with intermediate nodes
                foreach (var destId in node.EdgesOut)
                {
                    if (!node.Intermediates.ContainsKey(destId))
                        continue;
                        
                    if (graph.NodeMap.TryGetValue(destId, out NodeModel destNode))
                    {
                        StraightenPath(node, destNode, node.Intermediates[destId]);
                    }
                }
            }
        }

        /// <summary>
        /// Straightens a path between source and destination nodes through intermediate nodes
        /// </summary>
        private static void StraightenPath(NodeModel source, NodeModel dest, List<NodeModel> intermediates)
        {
            if (intermediates == null || intermediates.Count == 0)
                return;
            
            // Calculate a direct line from source to destination
            float startY = source.ScaledLocation.Y;
            float endY = dest.ScaledLocation.Y;
            float totalXDistance = dest.ScaledLocation.X - source.ScaledLocation.X;
            
            // Position each intermediate node to follow a more direct path
            for (int i = 0; i < intermediates.Count; i++)
            {
                NodeModel intermediate = intermediates[i];
                
                // Calculate the progress along the X-axis (0.0 to 1.0)
                float startX = source.ScaledLocation.X;
                float xProgress = (intermediate.ScaledLocation.X - startX) / totalXDistance;
                
                // Calculate the ideal Y position along a direct line
                float idealY = startY + (xProgress * (endY - startY));
                
                // Mix the ideal position with the current position for stability
                float strength = Config.PathStraighteningStrength;
                intermediate.ScaledLocation.Y = (strength * idealY) + ((1 - strength) * intermediate.ScaledLocation.Y);
            }
        }

        /// <summary>
        /// Applies a final smoothing pass to edge paths for better visual flow
        /// </summary>
        private static void SmoothEdgePaths(Graph graph, bool incremental)
        {
            // Group edges by source-target pairs to identify parallel edges
            Dictionary<(int, int), List<List<NodeModel>>> parallelEdgePaths = new Dictionary<(int, int), List<List<NodeModel>>>();
            
            // Collect all edge paths
            foreach (var node in graph.NodeMap.Values)
            {
                if (node.EdgesOut == null || node.EdgesOut.Length == 0) 
                    continue;
                    
                foreach (var destId in node.EdgesOut)
                {
                    if (!graph.NodeMap.TryGetValue(destId, out NodeModel destNode))
                        continue;
                    
                    // Skip in incremental mode if not dirty
                    if (incremental && !_dirtyNodes.Contains(node.ID) && !_dirtyNodes.Contains(destId))
                        continue;
                    
                    var key = (node.ID, destId);
                    List<NodeModel> path;
                    
                    // Create path including intermediates
                    if (node.Intermediates != null && node.Intermediates.ContainsKey(destId))
                    {
                        path = new List<NodeModel> { node };
                        path.AddRange(node.Intermediates[destId]);
                        path.Add(destNode);
                    }
                    else
                    {
                        path = new List<NodeModel> { node, destNode };
                    }
                    
                    // Add to parallel edges dictionary
                    if (!parallelEdgePaths.ContainsKey(key))
                    {
                        parallelEdgePaths[key] = new List<List<NodeModel>>();
                    }
                    parallelEdgePaths[key].Add(path);
                }
            }
            
            // Apply bundling to parallel edges
            foreach (var edgePaths in parallelEdgePaths.Values)
            {
                if (edgePaths.Count <= 1) 
                    continue;
                    
                ApplyEdgeBundling(edgePaths);
            }
            
            // Apply a Catmull-Rom smoothing to long edge paths
            foreach (var node in graph.NodeMap.Values)
            {
                if (node.EdgesOut == null || node.Intermediates == null) 
                    continue;
                
                foreach (var destId in node.EdgesOut)
                {
                    if (!node.Intermediates.ContainsKey(destId) || 
                        node.Intermediates[destId].Count < 3)
                        continue;
                        
                    ApplyCatmullRomSmoothing(node, destId, node.Intermediates[destId]);
                }
            }
        }

        /// <summary>
        /// Applies bundling to parallel edge paths to reduce visual clutter
        /// </summary>
        private static void ApplyEdgeBundling(List<List<NodeModel>> parallelPaths)
        {
            // Skip if there's only one path
            if (parallelPaths.Count <= 1) 
                return;
                
            // Skip if paths don't have comparable structures
            if (parallelPaths.Any(p => p.Count != parallelPaths[0].Count))
                return;
                
            int pathLength = parallelPaths[0].Count;
            
            // For each position along the paths (skip source and target)
            for (int i = 1; i < pathLength - 1; i++)
            {
                // Calculate average Y position at this step
                float avgY = 0;
                foreach (var path in parallelPaths)
                {
                    avgY += path[i].ScaledLocation.Y;
                }
                avgY /= parallelPaths.Count;
                
                // Move each path node toward the average
                foreach (var path in parallelPaths)
                {
                    NodeModel node = path[i];
                    node.ScaledLocation.Y = node.ScaledLocation.Y * (1 - Config.EdgeBundlingFactor) + 
                                            avgY * Config.EdgeBundlingFactor;
                }
            }
        }

        /// <summary>
        /// Applies Catmull-Rom smoothing to a path with many intermediate nodes
        /// </summary>
        private static void ApplyCatmullRomSmoothing(NodeModel source, int destId, List<NodeModel> intermediates)
        {
            if (intermediates == null || intermediates.Count < 3)
                return;
            
            // Create a copy of the original y-coordinates
            float[] originalY = new float[intermediates.Count];
            for (int i = 0; i < intermediates.Count; i++)
            {
                originalY[i] = intermediates[i].ScaledLocation.Y;
            }
            
            // Apply smoothing (skip first and last which connect to actual nodes)
            for (int i = 1; i < intermediates.Count - 1; i++)
            {
                // Get points for Catmull-Rom calculation
                float p0 = (i > 1) ? originalY[i - 2] : source.ScaledLocation.Y;
                float p1 = originalY[i - 1];
                float p2 = originalY[i + 1];
                float p3 = (i < intermediates.Count - 2) ? originalY[i + 2] : 
                           (originalY[intermediates.Count - 1] * 2 - originalY[intermediates.Count - 2]);
                
                // Catmull-Rom interpolation for smooth path
                float smoothedY = 0.5f * (
                    2 * p1 +
                    (-p0 + p2) * 0.5f +
                    (2 * p0 - 5 * p1 + 4 * p2 - p3) * 0.25f
                );
                
                // Update with smoothed value
                intermediates[i].ScaledLocation.Y = smoothedY;
            }
        }

        /// <summary>
        /// Optimizes alignment of intermediate nodes to create smoother paths
        /// </summary>
        private static void OptimizeIntermediateNodeAlignment(Graph graph, bool incremental)
        {
            // Skip if no optimizations needed
            if (incremental && _dirtyNodes.Count == 0)
                return;
                
            // Process each node with intermediate connections
            foreach (var node in graph.NodeMap.Values)
            {
                if (node.Intermediates == null || node.Intermediates.Count == 0)
                    continue;
                    
                // Skip if not needed in incremental mode
                if (incremental && !_dirtyNodes.Contains(node.ID) && 
                    !node.EdgesOut.Any(id => _dirtyNodes.Contains(id)))
                    continue;
                
                // Process each edge with intermediates
                foreach (var destId in node.EdgesOut)
                {
                    if (!node.Intermediates.ContainsKey(destId))
                        continue;
                        
                    List<NodeModel> intermediates = node.Intermediates[destId];
                    if (intermediates.Count < 2)
                        continue;
                        
                    // Get destination node
                    if (!graph.NodeMap.TryGetValue(destId, out NodeModel destNode))
                        continue;
                    
                    // Apply vertical alignment optimization
                    AlignIntermediateNodes(node, destNode, intermediates);
                }
            }
        }

        /// <summary>
        /// Aligns a series of intermediate nodes to create a smoother path
        /// </summary>
        private static void AlignIntermediateNodes(NodeModel source, NodeModel dest, List<NodeModel> intermediates)
        {
            if (intermediates.Count < 2)
                return;
                
            // Get start and end points
            float startY = source.ScaledLocation.Y;
            float endY = dest.ScaledLocation.Y;
            
            // Calculate a penalty for each possible vertical position of intermediates
            for (int i = 0; i < intermediates.Count; i++)
            {
                NodeModel current = intermediates[i];
                
                // Calculate progress through the path (0.0 to 1.0)
                float progress = (float)(i + 1) / (intermediates.Count + 1);
                
                // Target Y position for a straight line
                float targetY = startY + (progress * (endY - startY));
                
                // Calculate constraints from adjacent ranks
                float minY = float.MinValue;
                float maxY = float.MaxValue;
                
                // Get rank constraints
                if (current.ParentRank != null && current.ParentRank.Column.Count > 1)
                {
                    int idx = current.ParentRank.Column.IndexOf(current);
                    if (idx > 0)
                    {
                        NodeModel prev = current.ParentRank.Column[idx - 1];
                        minY = prev.ScaledLocation.Y + (prev.ScaledSize / 2) + (current.ScaledSize / 2);
                    }
                    
                    if (idx < current.ParentRank.Column.Count - 1)
                    {
                        NodeModel next = current.ParentRank.Column[idx + 1];
                        maxY = next.ScaledLocation.Y - (next.ScaledSize / 2) - (current.ScaledSize / 2);
                    }
                }
                
                // Mix the current position with the target position
                float newY = current.ScaledLocation.Y * (1 - Config.PathStraighteningStrength) + 
                            targetY * Config.PathStraighteningStrength;
                
                // Apply constraints
                if (minY != float.MinValue) newY = Math.Max(newY, minY);
                if (maxY != float.MaxValue) newY = Math.Min(newY, maxY);
                
                // Apply the optimized position
                current.ScaledLocation.Y = newY;
            }
        }
    }
}
